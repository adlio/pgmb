// +build ignore

package main

import (
	"fmt"
	"html/template"
	"log"
	"os"
	"strings"
)

type Table struct {
	Name           string
	PluralName     string
	TableName      string
	DefaultColumns string
}

func main() {

	tables := []Table{
		{"Area", "Areas", "area", "id, gid, name"},
		{"Artist", "Artists", "artist", "id, gid, name, sort_name, begin_date_year, end_date_year"},
		{"ArtistAlias", "ArtistAliases", "artist_alias", "id, artist, name, sort_name"},
		{"ArtistCredit", "ArtistCredits", "artist_credit", "id, name, artist_count, ref_count, ARRAY(SELECT n.artist FROM artist_credit_name n WHERE n.artist_credit = artist_credit.id) as artist_ids"},
		{"Recording", "Recordings", "recording", "id, gid, name, artist_credit, length, comment"},
		{"ReleaseGroup", "ReleaseGroups", "release_group", "id, gid, name, type, artist_credit, comment, ARRAY(SELECT j.secondary_type FROM release_group_secondary_type_join j WHERE j.release_group = release_group.id) as secondary_type_ids"},
		{"ReleaseGroupPrimaryType", "ReleaseGroupPrimaryTypes", "release_group_primary_type", "id, gid, name, child_order"},
		{"Release", "Releases", "release", "id, gid, name, artist_credit, release_group, status, packaging, comment, barcode, quality"},
		{"ReleaseEvent", "ReleaseEvents", "release_event", "release, country, date_year, date_month, date_day"},
		{"ReleaseStatus", "ReleaseStatuses", "release_status", "id, gid, name, child_order, description"},
		{"ReleasePackaging", "ReleasePackagings", "release_packaging", "id, gid, name, child_order, description"},
	}

	for _, table := range tables {
		filename := strings.Replace(strings.ToLower(table.TableName), "_", "-", -1) + ".gen.go"
		fmt.Println("Generating " + filename)
		f, err := os.Create(filename)
		die(err)
		defer f.Close()
		queryTemplate.Execute(f, table)
	}
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

var queryTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
package pgmb

import (
	"strings"
	"github.com/pkg/errors"
)

// {{ .Name }}Query is a queryer for {{ .Name }} data
type {{ .Name }}Query struct {
	db      DB
	builder SelectBuilder
	processors []{{ .Name }}CollectionProcessor
}

// {{ .PluralName }} is the constructor for {{ .Name }}Query
func {{ .PluralName }}(db DB, columns ...string) {{ .Name }}Query {

	var selectClause string
	if len(columns) > 0 {
		selectClause = strings.Join(columns, ", ")
	} else {
		selectClause = "{{ .DefaultColumns }}"
	}

	q := {{ .Name }}Query{
		db:      db,
		builder: SelectBuilder{}.Select(selectClause).From("{{ .TableName }}"),
	}
	return q
}

// {{ .Name }}Collection is a slice of {{ .Name }}
type {{ .Name }}Collection []*{{ .Name }}

// {{ .Name }}CollectionProcessor is a function which modifies each element in a {{ .Name }}Collection
// (typically by populting additional data on it)
type {{ .Name }}CollectionProcessor func(DB, {{ .Name }}Collection) error

// Select adjusts the columns returned from the query
func (q {{ .Name }}Query) Select(columns string) {{ .Name }}Query {
	q.builder = q.builder.Select(columns)
	return q
}

// Where adds an additional where clause to the query
func (q {{ .Name }}Query) Where(cmd string, args ...interface{}) {{ .Name }}Query {
	q.builder = q.builder.Where(cmd, args...)
	return q
}

// OrderBy adjusts the ordering criteria for the query
func (q {{ .Name }}Query) OrderBy(cmd string) {{ .Name }}Query {
	q.builder = q.builder.OrderBy(cmd)
	return q
}

// All returns all results from the query
func (q {{ .Name }}Query) All() (results {{ .Name }}Collection, err error) {
	results = make({{ .Name }}Collection, 0)
	err = Select(q.db, &results, q.builder)
	if err != nil {
		err = errors.Wrap(err, "{{ .Name }}Query.All() failed to populate {{ .Name }}Collection.")
		return
	}
	for _, f := range q.processors {
		err = f(q.db, results)
		if err != nil {
			err = errors.Wrap(err, "Failed to run processor over {{ .Name }}Collection.")
		}
	}
	return
}

// One returns a single result from the query
func (q {{ .Name }}Query) One() (result *{{ .Name }}, err error) {
	results := make({{ .Name }}Collection, 0, 1)
	err = Select(q.db, &results, q.builder)
	if err != nil {
		err = errors.Wrap(err, "{{ .Name }}Query.One() failed to populate initial result set.")
		return
	}

	for _, f := range q.processors {
		err = f(q.db, results)
		if err != nil {
			err = errors.Wrap(err, "Failed to run processor over {{ .Name }}Collection.")
			return
		}
	}

	if len(results) > 0 {
		result = results[0]
	}

	return result, nil
}
`))
