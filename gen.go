// +build ignore

package main

import (
	"fmt"
	"html/template"
	"log"
	"os"
)

type Table struct {
	Name       string
	PluralName string
	FileName   string
}

func main() {

	tables := []Table{
		{"Area", "Areas", "area"},
		{"Artist", "Artists", "artist"},
		{"ArtistAlias", "ArtistAliases", "artist-alias"},
		{"ArtistCredit", "ArtistCredits", "artist-credit"},
		{"DeepTrack", "DeepTracks", "deep-track"},
		{"Recording", "Recordings", "recording"},
		{"ReleaseGroup", "ReleaseGroups", "release-group"},
		{"ReleaseGroupPrimaryType", "ReleaseGroupPrimaryTypes", "release-group-primary-type"},
		{"Release", "Releases", "release"},
		{"ReleaseEvent", "ReleaseEvents", "release-event"},
		{"ReleaseStatus", "ReleaseStatuses", "release-status"},
		{"ReleasePackaging", "ReleasePackagings", "release-packaging"},
	}

	for _, table := range tables {
		filename := table.FileName + ".gen.go"
		fmt.Println("Generating " + filename)
		f, err := os.Create(filename)
		die(err)
		defer f.Close()
		queryTemplate.Execute(f, table)
	}
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

var queryTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
package pgmb

import (
	sq "github.com/Masterminds/squirrel"
	"github.com/pkg/errors"
)

// {{ .Name }}QueryFunc can be chained together to modify a {{ .Name }}Query
type {{ .Name }}QueryFunc func({{ .Name }}Query) {{ .Name }}Query

// {{ .Name }}Query is a queryer for {{ .Name }} data
type {{ .Name }}Query struct {
	db      		DB
	builder 		sq.SelectBuilder
	processors	[]{{ .Name }}CollectionProcessor
}

// {{ .PluralName }} is the constructor for {{ .Name }}Query
func {{ .PluralName }}(db DB) {{ .Name }}Query {
	q := {{ .Name }}Query{
		db:      db,
		builder: {{ .Name }}Select(),
	}
	return q
}

// {{ .Name }}Collection is a slice of {{ .Name }}
type {{ .Name }}Collection []*{{ .Name }}

// {{ .Name }}CollectionProcessor is a function which modifies each element in a {{ .Name }}Collection
// (typically by populting additional data on it)
type {{ .Name }}CollectionProcessor func(DB, {{ .Name }}Collection) error

// Select can be used to replace {{ .Name }}Select() with a different squirrel.SelectBuilder
// to pull different fields or join data differently.
func (q {{ .Name }}Query) Select(b sq.SelectBuilder) {{ .Name }}Query {
	q.builder = b
	return q
}

// Where adds an additional where clause to the query
func (q {{ .Name }}Query) Where(cmd string, args ...interface{}) {{ .Name }}Query {
	q.builder = q.builder.Where(cmd, args...)
	return q
}

// OrderBy adjusts the ordering criteria for the query
func (q {{ .Name }}Query) OrderBy(cmd string) {{ .Name }}Query {
	q.builder = q.builder.OrderBy(cmd)
	return q
}

// All returns all results from the query
func (q {{ .Name }}Query) All() (results {{ .Name }}Collection, err error) {
	results = make({{ .Name }}Collection, 0)
	err = Select(q.db, &results, q.builder)
	if err != nil {
		err = errors.Wrap(err, "{{ .Name }}Query.All() failed to populate {{ .Name }}Collection.")
		return
	}
	for _, f := range q.processors {
		err = f(q.db, results)
		if err != nil {
			err = errors.Wrap(err, "Failed to run processor over {{ .Name }}Collection.")
		}
	}
	return
}

// One returns a single result from the query
func (q {{ .Name }}Query) One() (result *{{ .Name }}, err error) {
	results := make({{ .Name }}Collection, 0, 1)
	err = Select(q.db, &results, q.builder)
	if err != nil {
		err = errors.Wrap(err, "{{ .Name }}Query.One() failed to populate initial result set.")
		return
	}

	for _, f := range q.processors {
		err = f(q.db, results)
		if err != nil {
			err = errors.Wrap(err, "Failed to run processor over {{ .Name }}Collection.")
			return
		}
	}

	if len(results) > 0 {
		result = results[0]
	}

	return result, nil
}
`))
